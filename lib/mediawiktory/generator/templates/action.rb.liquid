# frozen_string_literal: true

require 'json'
require 'hashie'

module {{ namespace }}
  class Action
    attr_reader :client

    def initialize(client, options = {})
      @client = client
      @params = Util.stringify_hash(options)
    end

    def merge(hash)
      self.class.new(@client, @params.merge(Util.stringify_hash(hash)))
    end

    def to_h
      @params.dup
    end

    def to_param
      to_h.merge('action' => action_name)
    end

    def perform
      fail NotImplementedError,
           'Action is abstract, all actions should descend from GetAction or PostAction'
    end

{% for param in object.main.params %}{% include 'param_method' %}{% endfor %}
    private

    def action_name
      self.class.name.scan(/(\w+)$/).flatten.first
        &.gsub(/([a-z])([A-Z])/, '\1-\2') # ParsoidBatch # => parsoid-batch
        &.downcase or
        fail ArgumentError, "Can't guess action name from #{self.class.name}"
    end

    # Used by generated code in methods like
    #
    # ```ruby
    # action.format(:json)
    # ```
    #
    # It merges used module name into action params and includes submodule's methods into action
    # for further tweaking.
    def merge_module(name, val, modules)
      mod = modules.fetch(val) { fail ArgumentError, "Module #{val} is not defined" }
      merge(name => val).extend(mod)
    end

    def merge_modules(name, vals, modules)
      mods =
        vals
        .map { |val| modules.fetch(val) { fail ArgumentError, "Module #{val} is not defined" } }
      merge(name => vals.join('|')).tap { |res| mods.each { |mod| res.extend(mod) } }
    end
  end

  class GetAction < Action
    def perform
      client.get(to_param)
    end
  end

  class PostAction < Action
    def perform
      client.post(to_param)
    end
  end
end
